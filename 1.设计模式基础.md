# 1.设计模式基础

## 1.1.设计模式是什么

* 设计模式是指在软件开发中,经过验证的,用于解决在特定环境下重复出现的、特定问题的解决方案.
  * 解决方案就是解决办法.
  * 特定问题说明其不是银弹,仅仅能解决某个特定的问题.
  * 设计模式是解决重复出现的问题的,复用总结过的问题解决方案.
  * 设计模式是用在特定环境下的,任何问题的出现都是有场景的,不能脱离环境去讨论对问题的解决办法.
  * 设计模式是经过验证的,这些解决方案只有经过足够的应用来验证,并得到大家的认可和验证

## 1.1.接口回顾

### 1.1.1.接口的概念

接口是一种特殊的抽象类,gen其他抽象类相比,接口里面的所有方法都是抽象方法,接口里面的所有属性都是常量.

### 1.1.2.接口的作用

接口定义实现类的外观,即实现类的行为定义,用来约束实现类的行为.接口相当于一份契约,根据外部应用需要的功能,约定了实现类应该要实现的功能.

通过使用接口,可以实现不相关类的相同行为,而不需考虑这些类之间的层次关系,接口就是实现类对外的外观

### 1.1.3.接口的思想

封装隔离

封装是对被隔离体的职责的封装

隔离是指外部调用和内部实现,外部调用只能通过接口进行调用,外部调用是不知道内部具体实现的.

### 1.1.4.接口的好处

接口由于隔离了外部调用与内部实现,保证了系统的可插拔性,提高了扩展性和可维护性

### 1.1.5.接口和抽象类的选择

1. 优先选用接口
2. 在既要定义子类行为,又要为子类提供公共的功能时应选择抽象类

## 1.2.面向对象设计原则

### 1.2.1.单一职责原则

#### 单一职责原则定义

- 单一职责原则：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。
- 就一个类而言，应该仅有一个引起它变化的原因

#### 单一职责原则分析 

- 一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小
- 当一个职责变化时，可能会影响其他职责的运作
- 将这些职责进行分离，将不同的职责封装在不同的类中
- 将不同的变化原因封装在不同的类中
- 单一职责原则是实现高内聚、低耦合的指导方针

#### 单一职责原则实例

![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-1-3-1.png)
![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-1-3-2.png)


### 1.2.2 开闭原则

#### 开闭原则定义

- 开闭原则：软件实体应当对扩展开放，对修改关闭。

#### 开闭原则实例

![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-2-2-1.png)

#### 开闭原则分析 
- 抽象化是开闭原则的关键
- 相对稳定的抽象层 + 灵活的具体层
- 对可变性封装原则(Principle of Encapsulation of Variation, EVP)：找到系统的可变因素并将其封装起来

### 1.2.3.里氏代换原则

#### 里氏代换原则定义

- 里氏代换原则：所有引用基类的地方必须能透明地使用其子类的对象。

#### 里氏代换原则分析

- 在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象
- 在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型
- 里氏代换原则是实现开闭原则的重要方式之一
- Java、C#等面向对象语言中，在编译阶段，编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。

### 1.2.4.依赖倒转原则

#### 依赖倒转原则定义

- 依赖倒转原则：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。
- 要针对接口编程，不要针对实现编程

#### 依赖倒转原则分析

- 在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等
- 在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中
- 针对抽象层编程，将具体类的对象通过依赖注入(Dependency Injection, DI)的方式注入到其他对象
    - 构造注入
    - 设值注入（Setter注入）
    - 接口注入

#### 依赖倒转原则示例

![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-4-3-1.png)

![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-4-3-2.png)


- 在大多数情况下，这三个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致


### 1.2.5.接口隔离原则

#### 接口隔离原则定义

- 接口隔离原则：客户端不应该依赖那些它不需要的接口。

#### 接口隔离原则分析 

- 当一个接口太大时，需要将它分割成一些更细小的接口
- 使用该接口的客户端仅需知道与之相关的方法即可
- 每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干
- 一个类型所提供的所有方法特征的集合。一个接口代表一个角色，每个角色都有它特定的一个接口，“角色隔离原则”
- 狭义的特定语言的接口。接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口，每个接口中只包含一个客户端所需的方法，“定制服务”

#### 接口隔离原则示例

![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-5-3-1.png)
![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-5-3-2.png)

### 1.2.6.合成复用原则

#### 合成复用原则定义

- 合成复用原则：优先使用对象组合，而不是继承来达到复用的目的。

##### 合成复用原则分析

- 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分
- 新对象通过委派调用已有对象的方法达到复用功能的目的
- 复用时要尽量使用组合/聚合关系（关联关系），少用继承
- 继承复用：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（“白箱”复用 ）
- 组合/聚合复用：耦合度相对较低，有选择性地调用成员对象的操作；可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。（“黑箱”复用 ）



#### 合成复用原则示例

![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-6-1-1.png)
![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-6-1-2.png)

- CustomerDAO和DBUtil之间的关系由继承关系变为关联关系，采用依赖注入的方式将DBUtil对象注入到CustomerDAO中，可以使用构造注入，也可以使用Setter注入。如果需要对DBUtil的功能进行扩展，可以通过其子类来实现，如通过子类OracleDBUtil来连接Oracle数据库。
- 由于CustomerDAO针对DBUtil编程，根据里氏代换原则，DBUtil子类的对象可以覆盖DBUtil对象，只需在CustomerDAO中注入子类对象即可使用子类所扩展的方法。
- 例如在CustomerDAO中注入OracleDBUtil对象，即可实现Oracle数据库连接，原有代码无须进行修改，而且还可以很灵活地增加新的数据库连接方式。

### 1.2.7.迪米特法则

#### 迪米特法则定义

- 迪米特法则：每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。

#### 迪米特法则分析

- 迪米特法则要求一个软件实体应当尽可能少地与其他实体发生相互作用
- 应用迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系
- 迪米特法则要求在设计系统时，应该尽量减少对象之间的交互
- 如果两个对象之间不必彼此直接通信，那么这两个对象就不应该发生任何直接的相互作用
- 如果其中一个对象需要调用另一个对象的方法，可以通过“第三者”转发这个调用
- 通过引入一个合理的“第三者”来降低现有对象之间的耦合度


#### 迪米特法则

![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-7-3-1.png)
![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-7-3-2.png)
![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-7-3-3.png)
![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/0-7-3-3.png)

## 1.3.设计模式分类

- 根据其目的（模式是用来做什么的）可分为创建型(Creational)，结构型(Structural)和行为型(Behavioral)三种：
    1. 创建型模式主要用于创建对象。
    2. 结构型模式主要用于处理类或对象的组合。
    3. 行为型模式主要用于描述对类或对象怎样交互和怎样分配职责。
- 根据范围，即模式主要是用于处理类之间关系还是处理对象之间的关系，可分为类模式和对象模式两种：
    1. 类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，是属于静态的。 
    2. 对象模式处理对象间的关系，这些关系在运行时刻变化，更具动态性。 

## 1.4.GoF设计模式简介 

![image](http://clsaazydpimgbed-10042610.cos.myqcloud.com/1-3-1-1.png)