# 12.观察者模式

## 12.1.场景问题

### 12.1.1.订阅报纸的过程

来考虑实际生活中订阅报纸的过程，这里简单总结了一下订阅报纸的基本流程，如下：

（1）首先按照自己的需要选择合适的报纸，具体的报刊杂志目录可以从邮局获取。

（2）选择好后，就到邮局去填写订阅单，同时交纳所需的费用。

至此，就完成了报纸的订阅过程，接下来就是耐心等候，报社会按照出报时间推出报纸，然后报纸会被送到每个订阅人的手里。

画个图来描述上述过程，如图12.1所示。

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-04-01-045717.png)

虽然看起来订阅者是直接跟邮局在打交道，但实际上，订阅者的订阅数据是会被邮局传递到报社的，当报社出版了报纸，报社会按照订阅信息把报纸交给邮局，然后由邮局来代为发送到订阅者的手中。所以在整个过程中，邮局只不过起到一个中转的作用。为了简单，我们去掉邮局，让订阅者直接和报社交互，如图12.2所示。

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-04-01-045856.png)

### 12.1.2.订阅报纸的问题

在上述过程中，订阅者在完成订阅后，最关心的问题就是何时能收到新出的报纸。幸好在现实生活中，报纸都是定期出版，这样发放到订阅者手中也基本上有一个大致的时间范围，差不多到时间了，订阅者就会看看邮箱，查收新的报纸。

要是报纸出版的时间不固定呢？

那订阅者就麻烦了，如果订阅者想要第一时间阅读到新报纸，恐怕只能天天守着邮箱了，这未免也太痛苦了吧。

继续引申一下，用类来描述上述的过程，描述如下。

订阅者类向出版者类订阅报纸，很明显不会只有一个订阅者订阅报纸，订阅者类可以有很多；当出版者类出版新报纸的时候，多个订阅者类如何知道呢？还有订阅者类如何得到新报纸的内容呢？

把上面的问题对比描述一下：

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-04-01-045948.png)

## 12.2.解决方案

### 12.2.1.使用观察者模式来解决问题

用来解决上述问题的一个合理的解决方案就是观察者模式。那么什么是观察者模式呢？

1．观察者模式的定义

定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

2．应用观察者模式来解决的思路

在前面描述的订阅报纸的例子里面，对于报社来说，在一开始，它并不清楚究竟有多少个订阅者会来订阅报纸，因此，报社需要维护一个订阅者的列表，这样，当报社出版报纸的时候，才能够把报纸发放到所有的订阅者手中。对于订阅者来说，订阅者也就是看报的读者，多个订阅者会订阅同一份报纸。

这就出现了一个典型的一对多的对象关系，一个报纸对象，会有多个订阅者对象来订阅；当报纸出版的时候，也就是报纸对象改变的时候，需要通知所有的订阅者对象。那么怎么来建立并维护这样的关系呢？

观察者模式可以处理这种问题。观察者模式把这多个订阅者称为观察者：Observer，多个观察者观察的对象被称为目标：Subject。

一个目标可以有任意多个观察者对象，一旦目标的状态发生了改变，所有注册的观察者都会得到通知，然后各个观察者会对通知作出相应的响应，执行相应的业务功能处理，并使自己的状态和目标对象的状态保持一致。

### 12.2.2.观察者模式的结构和说明

Subject：目标对象，通常具有如下功能。

一个目标可以被多个观察者观察。

目标提供对观察者注册和退订的维护。

当目标的状态发生变化时，目标负责通知所有注册的、有效的观察者。

Observer：定义观察者的接口，提供目标通知时对应的更新方法，这个更新方法进行相应的业务处理，可以在这个方法里面回调目标对象，以获取目标对象的数据。

ConcreteSubject：具体的目标实现对象，用来维护目标状态，当目标对象的状态发生改变时，通知所有注册的、有效的观察者，让观察者执行相应的处理。

ConcreteObserver：观察者的具体实现对象，用来接收目标的通知，并进行相应的后续处理，比如更新自身的状态以保持和目标的相应状态一致。


### 12.2.3.观察者模式示例代码

先来看看目标对象的定义。

```java
import java.util.*;
/**
 * 目标对象，它知道观察它的观察者，并提供注册和删除观察者的接口
 */
public class Subject {
	/**
	 * 用来保存注册的观察者对象
	 */
	private List<Observer> observers = new ArrayList<Observer>();
	/**
	 * 注册观察者对象
	 * @param observer 观察者对象
	 */
	public void attach(Observer observer) {
		observers.add(observer);
	}
	/**
	 * 删除观察者对象
	 * @param observer 观察者对象
	 */
	public void detach(Observer observer) {
		observers.remove(observer);
	}
	/**
	 * 通知所有注册的观察者对象
	 */
	protected void notifyObservers() {
		for(Observer observer : observers){
			observer.update(this);
		}
	}
}
```

接下来看看具体的目标对象。

```java
/**
 * 具体的目标对象，负责把有关状态存入到相应的观察者对象，
 * 并在自己状态发生改变时，通知各个观察者
 */
public class ConcreteSubject extends Subject {
	/**
	 * 示意，目标对象的状态
	 */
	private String subjectState;
	public String getSubjectState() {
		return subjectState;
	}
	public void setSubjectState(String subjectState) {
		this.subjectState = subjectState;
		//状态发生了改变，通知各个观察者
		this.notifyObservers();
	}
}
```

```java
/**
 * 观察者接口，定义一个更新的接口给那些在目标发生改变的时候被通知的对象
 */
public interface Observer {
	/**
	 * 更新的接口
	 * @param subject 传入目标对象，好获取相应的目标对象的状态
	 */
	public void update(Subject subject);

}

```

```java
]/**
 * 具体观察者对象，实现更新的方法，使自身的状态和目标的状态保持一致
 */
public class ConcreteObserver implements Observer {
	/**
	 * 示意，观者者的状态
	 */
	private String observerState;
	
	public void update(Subject subject) {
		// 具体的更新实现
		//这里可能需要更新观察者的状态，使其与目标的状态保持一致
		observerState = ((ConcreteSubject)subject).getSubjectState();
	}
}
```

### 12.2.4.使用观察者模式实现示例

要使用观察者模式来实现示例，那就按照前面讲述的实现思路，把报纸对象当作目标，订阅者当做观察者，就可以实现出来了。

使用观察者模式来实现示例的结构如图12.4所示。

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-04-01-051002.png)

还是来看看具体的代码实现。

1．被观察的目标

在前面描述的订阅报纸的例子里面，多个订阅者都是在观察同一个报社对象，这个报社对象就是被观察的目标。这个目标的接口应该有些什么方法呢？还是从实际入手去想，看看报社都有些什么功能。报社有以下最基本的功能。

■　注册订阅者，也就是说很多个人来订报纸，报社肯定要有相应的记录才行。

■　出版报纸，这个是报社的主要工作。

■　发行报纸，也就是要把出版的报纸发送到订阅者手中。

■　退订报纸，当订阅者不想继续订阅了，可以取消订阅。

上面这些功能是报社最基本的功能，当然，报社还有很多别的功能，为了简单，这里就不再去描述了。因此报社这个目标的接口也应该实现上述功能，把它们定义在目标接口里面。示例代码如下：

```java
import java.util.ArrayList;
import java.util.List;

/**
 * 目标对象，作为被观察者
 */
public class Subject {
	/**
	 * 用来保存注册的观察者对象，也就是报纸的订阅者
	 */
	private List<Observer> readers = new ArrayList<Observer>();
	/**
	 * 报纸的读者需要先向报社订阅，先要注册
	 * @param reader 报纸的读者 
	 * @return 是否注册成功
	 */
	public void attach(Observer reader) {
		readers.add(reader);
	}
	/**
	 * 报纸的读者可以取消订阅
	 * @param reader 报纸的读者
	 * @return 是否取消成功
	 */
	public void detach(Observer reader) {
		readers.remove(reader);
	}
	/**
	 * 当每期报纸印刷出来后，就要迅速的主动的被送到读者的手中，
	 * 相当于通知读者，让他们知道
	 */
	protected void notifyObservers() {
		for(Observer reader : readers){
			reader.update(this);
		}
	}
}
```

```java

/**
 * 观察者，比如报纸的读者
 */
public interface Observer {
	/**
	 * 被通知的方法
	 * @param subject 具体的目标对象，可以获取报纸的内容
	 */
	public void update(Subject subject);
}
```

```java
/**
 * 真正的读者，为了简单就描述一下姓名
 */
public class Reader implements Observer{
	/**
	 * 读者的姓名
	 */
	private String name;

	public void update(Subject subject) {
		//这是采用拉的方式
		System.out.println(name+"收到报纸了，阅读先。内容是==="+((NewsPaper)subject).getContent());
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
```

```java
import java.util.*;
/**
 * 报纸对象，具体的目标实现
 */
public class NewsPaper extends Subject{
	/**
	 * 报纸的具体内容
	 */
	private String content;
	/**
	 * 获取报纸的具体内容
	 * @return 报纸的具体内容
	 */
	public String getContent() {
		return content;
	}
	/**
	 * 示意，设置报纸的具体内容，相当于要出版报纸了
	 * @param content 报纸的具体内容
	 */
	public void setContent(String content) {
		this.content = content;
		//内容有了，说明又出报纸了，那就通知所有的读者
		notifyObservers();
		
		
		System.out.println("nows paper content="+this.content);
	}
}
```

```java

public class Client {
	public static void main(String[] args) {
		//创建一个报纸，作为被观察者
		NewsPaper subject = new NewsPaper();
		
		//创建阅读者，也就是观察者
		Reader reader1 = new Reader();
		reader1.setName("张三");
		
		Reader reader2 = new Reader();
		reader2.setName("李四");
		
		Reader reader3 = new Reader();
		reader3.setName("王五");
		
		//注册阅读者
		subject.attach(reader1);
//		subject.attach(reader2);
		subject.attach(reader3);
		
		//要出报纸啦
		subject.setContent("本期内容是观察者模式");
	}
}
```

你还可以通过改变注册的观察者，或者是注册了又退订，来看看输出的结果。会发现没有注册或者退订的观察者是收不到报纸的。

如同前面的示例，读者和报社是一种典型的一对多的关系，一个报社有多个读者，当报社的状态发生改变，也就是出版新报纸的时候，所有注册的读者都会得到通知，然后读者会拿到报纸，读者会去阅读报纸并进行后续的操作。

## 12.3.模式讲解

### 12.3.1.认识观察者模式

#### 目标和观察者之间的关系

按照模式的定义，目标和观察者之间是典型的一对多的关系。

但是要注意，如果观察者只有一个，也是可以的，这样就变相实现了目标和观察者之间一对一的关系，这也使得在处理一个对象的状态变化会影响到另一个对象的时候，也可以考虑使用观察者模式。

同样地，一个观察者也可以观察多个目标，如果观察者为多个目标定义的通知更新方法都是update方法的话，这会带来麻烦，因为需要接收多个目标的通知，如果是一个update的方法，那就需要在方法内部区分，到底这个更新的通知来自于哪一个目标，不同的目标有不同的后续操作。

一般情况下，观察者应该为不同的观察者目标定义不同的回调方法，这样实现最简单，不需要在update方法内部进行区分。

#### 单向依赖

在观察者模式中，观察者和目标是单向依赖的，只有观察者依赖于目标，而目标是不会依赖于观察者的。

它们之间联系的主动权掌握在目标手中，只有目标知道什么时候需要通知观察者。在整个过程中，观察者始终是被动的，被动地等待目标的通知，等待目标传值给它。

对目标而言，所有的观察者都是一样的，目标会一视同仁地对待。当然也可以通过在目标中进行控制，实现有区别地对待观察者，比如某些状态变化，只需要通知部分观察者，但那是属于稍微变形的用法了，不属于标准的、原始的观察者模式了。

#### 基本的实现说明

■　具体的目标实现对象要能维护观察者的注册信息，最简单的实现方案就如同前面的例子那样，采用一个集合来保存观察者的注册信息。

■　具体的目标实现对象需要维护引起通知的状态，一般情况下是目标自身的状态。变形使用的情况下，也可以是别的对象的状态。

■　具体的观察者实现对象需要能接收目标的通知，能够接收目标传递的数据，或者是能够主动去获取目标的数据，并进行后续处理。

■　如果是一个观察者观察多个目标，那么在观察者的更新方法里面，需要去判断是来自哪一个目标的通知。一种简单的解决方案就是扩展update方法，比如在方法里面多传递一个参数进行区分等；还有一种更简单的方法，那就是干脆定义不同的回调方法。

#### 命名建议

■　观察者模式又被称为发布——订阅模式。

■　目标接口的定义，建议在名称后面跟Subject。

■　观察者接口的定义，建议在名称后面跟Observer。

■　观察者接口的更新方法，建议名称为update，当然方法的参数可以根据需要定义，参数个数不限、参数类型不限。

#### 触发通知的时机

提示

在实现观察者模式的时候，一定要注意触发通知的时机。一般情况下，是在完成了状态维护后触发，因为通知会传递数据，不能够先通知后改数据，这很容易出问题，会导致观察者和目标对象的状态不一致。

比如，目标一发出通知，就有观察者来取值，结果目标还没有更新数据，这就明显地造成了错误。如下示例就是有问题的。示例代码如下：

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-04-01-051408.png)

#### 相互观察

在某些应用中，可能会出现目标和观察者相互观察的情况。什么意思呢？比如有两套观察者模式的应用，其中一套观察者模式的实现是A对象、B对象观察C对象；在另一套观察者模式的实现里面，实现的是B对象、C对象观察A对象，那么A对象和C对象就是在相互观察。

换句话说，A对象的状态变化会引起C对象的联动操作，反过来，C对象的状态变化也会引起A对象的联动操作。对于出现这种状况，要特别小心处理，因为可能会出现死循环的情况。

#### 观察者模式的调用顺序示意图

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-04-01-051437.png)


#### 通知的顺序

从理论上来说，当目标对象的状态变化后通知所有观察者的时候，顺序是不确定的，因此观察者实现的功能，绝对不要依赖于通知的顺序。也就是说，多个观察者之间的功能是平行的，相互不应该有先后的依赖关系。


### 12.3.2.推模型和拉模型

■　推模型

目标对象主动向观察者推送目标的详细信息，不管观察者是否需要，推送的信息通常是目标对象的全部或部分数据，相当于是在广播通信。

■　拉模型

目标对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到目标对象中获取，相当于是观察者从目标对象中拉数据。一般这种模型的实现中，会把目标对象自身通过update方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。

根据上面的描述，发现前面的例子就是典型的拉模型，那么推模型如何实现呢？还是来看个示例吧，这样会比较清楚。

#### 推模型的观察者接口

根据前面的讲述，推模型通常都是把需要传递的数据直接推送给观察者对象，所以观察者接口中的update方法的参数需要发生变化。

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-04-01-051627.png)

#### 推模型的观察者的具体实现

以前需要到目标对象中获取自己需要的数据，现在是直接接收传入的数据，这就是改变的地方。示例代码如下：

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-04-01-051649.png)

#### 推模型的目标对象

跟拉模型的目标实现相比，有一些变化。

■　通知所有观察者的方法，以前是没有参数的，现在需要传入需要主动推送的数据。

■　在循环通知观察者的时候，也就是循环调用观察者的update方法的时候，传入的参数不同了。

示例代码如下：

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-04-01-051711.png)

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-04-01-051729.png)

#### 推模型的目标具体实现

跟拉模型相比，有一点变化，就是在调用通知观察者的方法的时候，需要传入参数了，拉模型的实现中是不需要的。示例代码如下：

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-04-01-051756.png)

#### 关于两种模型的比较

两种实现模型，在开发的时候，究竟应该使用哪一种，还应该具体问题具体分析。这里，只是把两种模型进行一个简单的比较。

■　推模型是假定目标对象知道观察者需要的数据；而拉模型是目标对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传给观察者，让观察者自己去按需取值。

■　推模型可能会使得观察者对象难以复用，因为观察者定义的update方法是按需而定义的，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能需要提供新的update方法，或者是干脆重新实现观察者。

而拉模型就不会造成这样的情况，因为拉模型下，update方法的参数是目标对象本身，这基本上是目标对象能传递的最大数据集合了，基本上可以适应各种情况的需要。

### 12.3.4.观察者模式的优缺点

观察者模式具有以下优点。

■　观察者模式实现了观察者和目标之间的抽象耦合

原本目标对象在状态发生改变的时候，需要直接调用所有的观察者对象，但是抽象出观察者接口以后，目标和观察者就只是在抽象层面上耦合了，也就是说目标只是知道观察者接口，并不知道具体的观察者的类，从而实现目标类和具体的观察者类之间解耦。

■　观察者模式实现了动态联动

所谓联动，就是做一个操作会引起其他相关的操作。由于观察者模式对观察者注册实行管理，那就可以在运行期间，通过动态地控制注册的观察者，来控制某个动作的联动范围，从而实现动态联动。

■　观察者模式支持广播通信

由于目标发送通知给观察者是面向所有注册的观察者，所以每次目标通知的信息就要对所有注册的观察者进行广播。当然，也可以通过在目标上添加新的功能来限制广播的范围。

在广播通信的时候要注意一个问题，就是相互广播造成死循环的问题。比如A和B两个对象互为观察者和目标对象，A对象发生状态变化，然后A来广播信息，B对象接收到通知后，在处理过程中，使得B对象的状态也发生了改变，然后B来广播信息，然后A对象接到通知后，又触发广播信息……，如此A引起B变化，B又引起A变化，从而一直相互广播信息，就造成死循环。

观察者模式的缺点是：

■　可能会引起无谓的操作

由于观察者模式每次都是广播通信，不管观察者需不需要，每个观察者都会被调用update方法，如果观察者不需要执行相应处理，那么这次操作就浪费了。其实浪费了还好，最怕引起误更新，那就麻烦了，比如，本应该在执行这次状态更新前把某个观察者删除掉，这样通知的时候就没有这个观察者了，但是现在忘掉了，那么就会引起误操作。

### 12.3.5.思考观察者模式

　　观察者模式的本质：触发联动。

1.观察者模式的本质

当修改目标对象的状态的时候，就会触发相应的通知，然后会循环调用所有注册的观察者对象的相应方法，其实就相当于联动调用这些观察者的方法。

而且这个联动还是动态的，可以通过注册和取消注册来控制观察者，因而可以在程序运行期间，通过动态地控制观察者，来变相地实现添加和删除某些功能处理，这些功能就是观察者在update的时候执行的功能。

同时目标对象和观察者对象的解耦，又保证了无论观察者发生怎样的变化，目标对象总是能够正确地联动过来。

理解这个本质对我们非常有用，对于我们识别和使用观察者模式有非常重要的意义，尤其是在变形使用的时候。万变不离其宗。

2．何时选用观察者模式

建议在以下情况中选用观察者模式。

■　当一个抽象模型有两个方面，其中一个方面的操作依赖于另一个方面的状态变化，那么就可以选用观察者模式，将这两者封装成观察者和目标对象，当目标对象变化的时候，依赖于它的观察者对象也会发生相应的变化。这样就把抽象模型的这两个方面分离开了，使得它们可以独立地改变和复用。

■　如果在更改一个对象的时候，需要同时连带改变其他的对象，而且不知道究竟应该有多少对象需要被连带改变，这种情况可以选用观察者模式，被更改的那一个对象很明显就相当于是目标对象，而需要连带修改的多个其他对象，就作为多个观察者对象了。

■　当一个对象必须通知其他的对象，但是你又希望这个对象和其他被它通知的对象是松散耦合的。也就是说这个对象其实不想知道具体被通知的对象。这种情况可以选用观察者模式，这个对象就相当于是目标对象，而被它通知的对象就是观察者对象了。

### 12.3.8.相关模式

■　观察者模式和状态模式

观察者模式和状态模式是有相似之处的。

观察者模式是当目标状态发生改变时，触发并通知观察者，让观察者去执行相应的操作。而状态模式是根据不同的状态，选择不同的实现，这个实现类的主要功能就是针对状态相应地操作，它不像观察者，观察者本身还有很多其他的功能，接收通知并执行相应处理只是观察者的部分功能。

当然观察者模式和状态模式是可以结合使用的。观察者模式的重心在触发联动，但是到底决定哪些观察者会被联动，这时就可以采用状态模式来实现了，也可以采用策略模式来进行选择需要联动的观察者。

■　观察者模式和中介者模式

观察者模式和中介者模式是可以结合使用的。

前面的例子中目标都只是简单地通知一下，然后让各个观察者自己去完成更新就结束了。如果观察者和被观察的目标之间的交互关系很复杂，比如，有一个界面，里面有三个下拉列表组件，分别是选择国家、省份/州、具体的城市，很明显这是一个三级联动，当你选择一个国家的对候，省份/州应该相应改变数据，省份/州一改变，具体的城市也需要改变。

这种情况下，很明显需要相关的状态都联动准备好了，然后再一次性地通知观察者。也就是界面做更新处理，不会仅国家改变一下，省份和城市还没有改，就通知界面更新。这种情况就可以使用中介者模式来封装观察者和目标的关系。在使用Swing的小型应用里面，也可以使用中介者模式，比如，把一个界面所有的事件用一个对象来处理，把一个组件触发事件以后，需要操作其他组件的动作都封装到一起，这个对象就是典型的中介者。

